// ----------------- Probleme de Laplace -----------------
// Resolution de -Laplacien(u) = f avec u = 0 au bord
// sur le carre [0,1]x[0,1] en elements finis P1 Lagrange

// verbosity = 0;
load "iovtk";

// -------------------------------------------------------
// Mise en place du probleme
// -------------------------------------------------------
// --- Parametres initiales (x0,y0) et finales (xx0,yy0)
real x0 (0.9), y0 (0.5);
real xx0(0.1), yy0(0.9);
cout << endl << " Position initiale : x0 = " << x0 << " , y0 = " << y0 << endl;

// Définition des bord du domaine de calcul
int n = 20;
// border G1(t=0,1) {x=t; y=0;};
// border G2(t=0,1) {x=1; y=t;};
// border G3(t=0,1) {x=1-t; y=1;};
// border G4(t=0,1) {x=0; y=1-t;};
// mesh Th = buildmesh(G1(n)+G2(n)+G3(n)+G4(n));
mesh Th = square(n,n,[x,y]);
// plot (Th);

// --- Définition de l'espace de discrétisation set des variables associées
fespace Vh(Th,P1);
Vh u,v,dI,bp;
Vh lambda;

// --- Définition du second membre
real K0;
real[int] K1(2);
real[int, int] K2(2,2);
K0 = 1;
K1 = [1,1];
K2 = [[1,0], [0,1]];

func g = K0 + K1(0)*(x-x0)+K1(1)*(y-y0)
        + (x-x0)*((x-x0)*K2(0,0)+(y-y0)*K2(0,1))
        + (y-y0)*((x-x0)*K2(1,0)+(y-y0)*K2(1,1));

func gg = K0 + K1(0)*(x-xx0)+K1(1)*(y-yy0)
        + (x-xx0)*((x-xx0)*K2(0,0)+(y-yy0)*K2(0,1))
        + (y-yy0)*((x-xx0)*K2(1,0)+(y-yy0)*K2(1,1));

func dgx = -K1(0) - 2*(x-xx0)*K2(0,0) - (y-yy0)*K2(0,1) - (y-yy0)*K2(1,0);
func dgy = -K1(1) - 2*(y-yy0)*K2(1,1) - (x-xx0)*K2(1,0) - (x-xx0)*K2(0,1);

// --- Capteurs
int nbCapteursX, nbCapteursY;
real pasX, pasY;

nbCapteursX = 3;
nbCapteursY = 3;

pasX = 1./(nbCapteursX+1);              // Distance entre
pasY = 1./(nbCapteursY+1);              // les capteurs

real[int] um(nbCapteursX*nbCapteursY);  // Valeur de la solution sur les capteurs

// --- Sensibility
int comp(0);
real i, j;
real errx, erry;
real eps = 0.000001;


real xC, yC;
int nbCap(0);

// real[int] boo(Vh.ndof);
real[int] vecti(nbCapteursX*nbCapteursY);
real[int] vectj(nbCapteursX*nbCapteursY);
for(int i=0;i<Th.nt;i++)
{
  for (int j=0; j<3; j++)
  {
    x = Th[i][j].x;
    y = Th[i][j].y;
    cout << x << "  " << y << endl;

    for (int c=0; c<nbCapteursX*nbCapteursY; ++c)
    {
      xC = (int(c/nbCapteursX)+1)*pasX;
      yC = (c%nbCapteursX+1)*pasY;
      // cout << xC << "  " << yC << endl;
      if ((abs(x-xC)<1e-6) && (abs(y-yC)<1e-6))
      {
        // cout << xC << "  " << yC << endl;
        vecti[c]=i;
        vectj[c]=j;
        nbCap++;
        break;
      }
    }
  }
}
// cout << nbCap << endl;
for (int c=0; c<nbCapteursX*nbCapteursY; ++c)
{
  func fcd = x+y;
  u = fcd;
  plot (u);
  cout << vecti[c] << "  " << vectj[c] << "  " << u[][Vh(vecti[c],vectj[c])] << endl;
}

/*
// -------------------------------------------------------
// Creation de la matrice A et du second membre b
// -------------------------------------------------------
// Definition d'une macro
macro grad(u) [dx(u),dy(u)]                                               //

// Matrice A
matrix A, At;
varf laplace(u,v) = int2d(Th)( grad(u)'*grad(v) ) + on(G1,G2,G3,G4,u=0);  // '
A = laplace(Vh,Vh);
At = A';
set(A,solver=UMFPACK);
set(At,solver=UMFPACK);

//Second membre b
Vh secMembre; real[int] b(Vh.ndof);
varf f(u,v) = int2d(Th)( g*v );
//f[] = f(0,Vh);
b = f(0,Vh);


// -------------------------------------------------------
// Resolution de Au = b avec (x0,y0) et sauvegarde des um
// -------------------------------------------------------
real[int] Uth(Vh.ndof);
// Résolution du système linéaire
Uth = A^-1*b;
u[] = Uth;
//plot(u, value=1, fill=1);

for (int i=0; i<nbCapteursX; ++i)
{
  for (int j=0; j<nbCapteursY; ++j)
  {
    um(i*nbCapteursX + j) = u((i+1)*pasX, (j+1)*pasY);
    // cout << "la : " << (i+1)*pasX << " " << (j+1)*pasY << endl;
  }
}


// -------------------------------------------------------
// Sensitivity Analisys
// -------------------------------------------------------
errx = 10; erry = 10;
real[int] Ue(Vh.ndof), dUx(Vh.ndof), dUy(Vh.ndof);
while ((sqrt(errx*errx + erry*erry) > eps) && (comp < 500))
{
  ++comp;
  // Résolution du système linéaire
  varf fe(u,v) = int2d(Th)( gg*v )+ on(G1,G2,G3,G4,u=0);;
  b = fe(0,Vh);
  Ue = A^-1*b;
  u[]=Ue;

  dI = 0;
  for(int k=0; k<nbCapteursX*nbCapteursY; k++)
  {
    i = (int(k/nbCapteursX)+1) * pasX;
    j = (k%nbCapteursX+1) * pasY;
    dI = dI + real((x>i-1e-2)&&(y>j-1e-2)&&(x<i+1e-2)&&(y<j+1e-2))*(u(i,j) - um(k));
    plot (dI, value=1, fill=1);
  }


  // Résolution du système linéaire
  varf fi(u,v) = int2d(Th)( dI*v )+ on(G1,G2,G3,G4,u=0);
  b = fi(0,Vh);
  lambda[] = At^-1*b;

  // Résolution du système linéaire
  varf fpx(u,v) = int2d(Th)( dgx*v )+ on(G1,G2,G3,G4,u=0);
  b = fpx(0,Vh);
  bp[] = At^-1*b;

  errx = lambda'*bp;

  // Résolution du système linéaire
  varf fpy(u,v) = int2d(Th)( dgy*v )+ on(G1,G2,G3,G4,u=0);
  b = fpy(0,Vh);
  bp[] = At^-1*b;

  erry = lambda'*bp;

  xx0 -= 1 * errx;
  yy0 -= 1 * erry;

  cout.flush;
  cout << " -- Iteration : " << comp << " ; Erreur (grad): " << sqrt(errx*errx+erry*erry) << "         \r";
  // cout << comp << "  " << errx << "  " << erry << endl;
}
cout << endl << " Position predite  : x0 = " << xx0 << " , y0 = " << yy0 << endl << endl;


// -------------------------------------------------------
// Sauvegarde des données des capteurs
// -------------------------------------------------------
// Trace les um dans un fichier capteurs.txt
ofstream cap("capteurs.txt");
cap << "Nombre de capteurs suivant x : " << nbCapteursX << endl;
cap << "Nombre de capteurs suivant y : " << nbCapteursY << endl;
cap << "Sol depuis : x0 = (" << x0 << "," << y0 << ")" << endl << endl;
for (int i=0; i<nbCapteursX*nbCapteursY; ++i)
{
  cap << (int(i/nbCapteursX)+1)*pasX << " " << (i%nbCapteursX+1)*pasY << " " << um(i) << endl;
}


// -------------------------------------------------------
// Sauvegarde de la solution pour gnuplot
//-------------------------------------------------------
// Trace de la solution dans un fichier
{
 ofstream file("sol.dat");
 for(int i=0;i<Th.nt;i++)
 {
   for (int j=0; j<3; j++)
   {
     file << Th[i][j].x << " " << Th[i][j].y << " " << u[][Vh(i,j)] << endl;
   }
   file << Th[i][0].x << " " << Th[i][0].y << " " << u[][Vh(i,0)] <<" \n\n\n";
 }
}
*/
