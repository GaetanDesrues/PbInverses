// ----------------- Probleme de Laplace -----------------
// Resolution de -Laplacien(u) = f avec u = 0 au bord
// sur le carre [0,1]x[0,1] en elements finis P1 Lagrange

// verbosity = 0;
load "iovtk";

// -------------------------------------------------------
// Mise en place du probleme
// -------------------------------------------------------
// --- Parametres initiales (x0,y0) et finales (xx0,yy0)
real x0 (0.9), y0 (0.5);
real xx0(0.1), yy0(0.9);
cout << endl << " Position initiale : x0 = " << x0 << " , y0 = " << y0 << endl;

// Définition des bord du domaine de calcul
int n = 10;
mesh Th = square(n,n,[x,y]);

// --- Définition de l'espace de discrétisation set des variables associées
fespace Vh(Th,P1);
Vh u,v,W,bp;
Vh lamb;
Vh[int] vh(2);

// --- Définition du second membre
real K0;
real[int] K1(2);
real[int, int] K2(2,2);
K0 = 1;
K1 = [1,1];
K2 = [[1,0], [0,1]];

func g = K0 + K1(0)*(x-x0)+K1(1)*(y-y0)
        + (x-x0)*((x-x0)*K2(0,0)+(y-y0)*K2(0,1))
        + (y-y0)*((x-x0)*K2(1,0)+(y-y0)*K2(1,1));

func gg = K0 + K1(0)*(x-xx0)+K1(1)*(y-yy0)
        + (x-xx0)*((x-xx0)*K2(0,0)+(y-yy0)*K2(0,1))
        + (y-yy0)*((x-xx0)*K2(1,0)+(y-yy0)*K2(1,1));

func dgx = -K1(0) - 2*(x-xx0)*K2(0,0) - (y-yy0)*K2(0,1) - (y-yy0)*K2(1,0);
func dgy = -K1(1) - 2*(y-yy0)*K2(1,1) - (x-xx0)*K2(1,0) - (x-xx0)*K2(0,1);

// --- Capteurs
int nbCapteursX, nbCapteursY;
real pasX, pasY;

nbCapteursX = 1;
nbCapteursY = 1;

pasX = 1./(nbCapteursX+1);              // Distance entre
pasY = 1./(nbCapteursY+1);              // les capteurs

real[int] um(nbCapteursX*nbCapteursY);  // Valeur de la solution sur les capteurs
real[int] vectC(nbCapteursX*nbCapteursY);
real xC, yC;

vh[0] = x;
vh[1] = y;
for (int n = 0; n < Vh.ndof; n++)
{
  for (int nC=0; nC<nbCapteursX*nbCapteursY; ++nC)
  {
    yC = (int(nC/nbCapteursX)+1)*pasX;
    xC = (nC%nbCapteursX+1)*pasY;
    if ((abs(vh[0][][n]-xC)<1e-12) && (abs(vh[1][][n]-yC)<1e-12))
    {
      vectC[nC]=n;
      break;
    }
  }
}

//// cout << nbCap << endl;
//for (int c=0; c<nbCapteursX*nbCapteursY; ++c)
//{
//  func fcd = x+y;
//  u = fcd;
//  //plot (u);
//  cout << vecti[c] << "  " << vectj[c] << "  " << u[][Vh(vecti[c],vectj[c])] << endl;
//}
// Check Capteurs
/*for (int n = 0; n < nbCapteursX*nbCapteursY; n++) {
    cout << n;
    for (int d = 0; d < 2; d++)
        cout << "  " << vectC[n]<< " " << vh[d][][vectC[n]];
    cout << endl;
}*/

// --- Sensibility
int comp(0);
real i, j;
real errx, erry;
real eps = 0.000001;


// -------------------------------------------------------
// Creation de la matrice A et du second membre b
// -------------------------------------------------------
// Definition d'une macro
macro grad(u) [dx(u),dy(u)]                                           //

// Matrice A
matrix A, At;
varf laplace(u,v) = int2d(Th)( grad(u)'*grad(v) ) + on(1,2,3,4,u=0);  // '
A = laplace(Vh,Vh);
At = A';                                                              // '
set(A,solver=UMFPACK);
set(At,solver=UMFPACK);

//Second membre b
Vh secMembre; real[int] b(Vh.ndof);
varf f(u,v) = int2d(Th)( g*v );
//f[] = f(0,Vh);
b = f(0,Vh);

//Mat B
func fK1 = K1(0); func fK2 = K1(1);
Vh vecK1, vecK2;
vecK1 = fK1; vecK2 = fK2;
matrix B,Bt;
B.resize(Vh.ndof+2,Vh.ndof);
B = [[A,vecK1[],vecK2[]]];
Bt = B';                                                              // '

// -------------------------------------------------------
// Resolution de Au = b avec (x0,y0) et sauvegarde des um
// -------------------------------------------------------
real[int] Uth(Vh.ndof);
// Résolution du système linéaire
Uth = A^-1*b;
u[] = Uth;
//plot(u, value=1, fill=1);

for (int i=0; i<nbCapteursX; ++i)
{
  for (int j=0; j<nbCapteursY; ++j)
  {
    um(i*nbCapteursX + j) = u((i+1)*pasX, (j+1)*pasY);
    // cout << "la : " << (i+1)*pasX << " " << (j+1)*pasY << endl;
  }
}


// -------------------------------------------------------
// Sensitivity Analisys
// -------------------------------------------------------
errx = 10; erry = 10;
real[int] Ue(Vh.ndof), dUx(Vh.ndof), dUy(Vh.ndof), lambda(Vh.ndof);
while ((sqrt(errx*errx + erry*erry) > eps) && (comp < 100))
{
  ++comp;
  // Résolution du système linéaire
  varf fe(u,v) = int2d(Th)( gg*v )+ on(1,2,3,4,u=0);;
  b = fe(0,Vh);
  Ue = A^-1*b;
  u[]=Ue;

  W = 0;
  for(int k=0; k<nbCapteursX*nbCapteursY; k++)
  {
    i = (int(k/nbCapteursX)+1) * pasX;
    j = (k%nbCapteursX+1) * pasY;
    W[][vectC[k]] = u[][vectC[k]] - um(k);
    plot (W, value=1, fill=1);
  }


  // Résolution du système linéaire
  varf fi(u,v) = int2d(Th)( W*v )+ on(1,2,3,4,u=0);
  b = fi(0,Vh);
  lambda = At^-1*b;
  lamb[] = lambda;

  plot (lamb, value=1, fill=1, wait=1);

  // Résolution du système linéaire
  varf fpx(u,v) = int2d(Th)( (dgx+dgy)*v )+ on(1,2,3,4,u=0);
  b = fpx(0,Vh);
  bp[] = At^-1*b;

  plot (bp, value=1, fill=1, wait=1);

  errx = lamb'*bp;

  // Résolution du système linéaire
  varf fpy(u,v) = int2d(Th)( dgy*v )+ on(1,2,3,4,u=0);
  b = fpy(0,Vh);
  bp[] = At^-1*b;

  plot (bp, value=1, fill=1, wait=1);

  erry = lamb'*bp;

  //Ue = At*lambda;                                                  // '
  //errx = 0;
  //for(int i=0; i< Vh.ndof; i++)
  //{
  //  errx = lambda(i)*K1(0);
  //  erry = lambda(i)*K1(1);
  //}
  //errx = errx*errx + erry*erry;
  //for(int i=0; i< Vh.ndof; i++)
  //  errx = errx + Ue(is)*Ue(i);
  //erry = errx;

  xx0 -= 1 * errx;
  yy0 -= 1 * erry;

  cout.flush;
  //cout << " -- Iteration : " << comp << " ; Erreur (grad): " << sqrt(errx*errx+erry*erry) << "         \r";
  cout << comp << "  " << errx << "  " << erry << endl;
}
cout << endl << " Position predite  : x0 = " << xx0 << " , y0 = " << yy0 << endl << endl;


// -------------------------------------------------------
// Sauvegarde des données des capteurs
// -------------------------------------------------------
// Trace les um dans un fichier capteurs.txt
ofstream cap("capteurs.txt");
cap << "Nombre de capteurs suivant x : " << nbCapteursX << endl;
cap << "Nombre de capteurs suivant y : " << nbCapteursY << endl;
cap << "Sol depuis : x0 = (" << x0 << "," << y0 << ")" << endl << endl;
for (int i=0; i<nbCapteursX*nbCapteursY; ++i)
{
  cap << (int(i/nbCapteursX)+1)*pasX << " " << (i%nbCapteursX+1)*pasY << " " << um(i) << endl;
}


// -------------------------------------------------------
// Sauvegarde de la solution pour gnuplot
//-------------------------------------------------------
// Trace de la solution dans un fichier
{
 ofstream file("sol.dat");
 for(int i=0;i<Th.nt;i++)
 {
   for (int j=0; j<3; j++)
   {
     file << Th[i][j].x << " " << Th[i][j].y << " " << u[][Vh(i,j)] << endl;
   }
   file << Th[i][0].x << " " << Th[i][0].y << " " << u[][Vh(i,0)] <<" \n\n\n";
 }
}
